"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[133],{2248:(a,n,s)=>{s.r(n),s.d(n,{data:()=>e});const e={key:"v-023b1f90",path:"/java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%B8%80.html",title:"Java 核心技术卷一",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"第 1 章 Java 程序设计概述",slug:"第-1-章-java-程序设计概述",children:[]},{level:2,title:"第 2 章 Java 程序设计环境",slug:"第-2-章-java-程序设计环境",children:[]},{level:2,title:"第 3 章 Java 的基本程序设计结构",slug:"第-3-章-java-的基本程序设计结构",children:[{level:3,title:"3.1 一个简单的 Java 应用程序",slug:"_3-1-一个简单的-java-应用程序",children:[]},{level:3,title:"3.2 注释",slug:"_3-2-注释",children:[]},{level:3,title:"3.3 数据类型",slug:"_3-3-数据类型",children:[]},{level:3,title:"3.4 变量",slug:"_3-4-变量",children:[]},{level:3,title:"3.5 运算符",slug:"_3-5-运算符",children:[]},{level:3,title:"3.6 字符串",slug:"_3-6-字符串",children:[]},{level:3,title:"3.7 输入输出",slug:"_3-7-输入输出",children:[]},{level:3,title:"3.8 控制流程",slug:"_3-8-控制流程",children:[]},{level:3,title:"3.9 大数值",slug:"_3-9-大数值",children:[]},{level:3,title:"3.10 数组",slug:"_3-10-数组",children:[]}]},{level:2,title:"第 4 章 对象与类",slug:"第-4-章-对象与类",children:[{level:3,title:"4.6 对象构造",slug:"_4-6-对象构造",children:[]},{level:3,title:"4.7 包",slug:"_4-7-包",children:[]},{level:3,title:"4.8 类路径（ClassPath）",slug:"_4-8-类路径-classpath",children:[]}]}],filePathRelative:"java/Java核心技术卷一.md",git:{updatedTime:1619408051e3,contributors:[]}}},462:(a,n,s)=>{s.r(n),s.d(n,{default:()=>i});var e=s(6252);const t=(0,e.uE)('<h1 id="java-核心技术卷一" tabindex="-1"><a class="header-anchor" href="#java-核心技术卷一" aria-hidden="true">#</a> Java 核心技术卷一</h1><h2 id="第-1-章-java-程序设计概述" tabindex="-1"><a class="header-anchor" href="#第-1-章-java-程序设计概述" aria-hidden="true">#</a> 第 1 章 Java 程序设计概述</h2><h2 id="第-2-章-java-程序设计环境" tabindex="-1"><a class="header-anchor" href="#第-2-章-java-程序设计环境" aria-hidden="true">#</a> 第 2 章 Java 程序设计环境</h2><h2 id="第-3-章-java-的基本程序设计结构" tabindex="-1"><a class="header-anchor" href="#第-3-章-java-的基本程序设计结构" aria-hidden="true">#</a> 第 3 章 Java 的基本程序设计结构</h2><h3 id="_3-1-一个简单的-java-应用程序" tabindex="-1"><a class="header-anchor" href="#_3-1-一个简单的-java-应用程序" aria-hidden="true">#</a> 3.1 一个简单的 Java 应用程序</h3><h3 id="_3-2-注释" tabindex="-1"><a class="header-anchor" href="#_3-2-注释" aria-hidden="true">#</a> 3.2 注释</h3><h3 id="_3-3-数据类型" tabindex="-1"><a class="header-anchor" href="#_3-3-数据类型" aria-hidden="true">#</a> 3.3 数据类型</h3><h4 id="_3-3-1-整型" tabindex="-1"><a class="header-anchor" href="#_3-3-1-整型" aria-hidden="true">#</a> 3.3.1 整型</h4><h4 id="_3-3-2-浮点类型" tabindex="-1"><a class="header-anchor" href="#_3-3-2-浮点类型" aria-hidden="true">#</a> 3.3.2 浮点类型</h4><h4 id="_3-3-3-char-类型" tabindex="-1"><a class="header-anchor" href="#_3-3-3-char-类型" aria-hidden="true">#</a> 3.3.3 char 类型</h4><h4 id="_3-3-4-unicode-和-char-类型" tabindex="-1"><a class="header-anchor" href="#_3-3-4-unicode-和-char-类型" aria-hidden="true">#</a> 3.3.4 Unicode 和 char 类型</h4><h4 id="_3-3-5-boolean-类型" tabindex="-1"><a class="header-anchor" href="#_3-3-5-boolean-类型" aria-hidden="true">#</a> 3.3.5 boolean 类型</h4><h3 id="_3-4-变量" tabindex="-1"><a class="header-anchor" href="#_3-4-变量" aria-hidden="true">#</a> 3.4 变量</h3><h4 id="_3-4-1-变量初始化" tabindex="-1"><a class="header-anchor" href="#_3-4-1-变量初始化" aria-hidden="true">#</a> 3.4.1 变量初始化</h4><h4 id="_3-4-2-常量" tabindex="-1"><a class="header-anchor" href="#_3-4-2-常量" aria-hidden="true">#</a> 3.4.2 常量</h4><p>利用关键字<strong>final</strong>指示常量</p><p>被<strong>final</strong>指示的变量只能被赋值一次，一旦被赋值就不能再更改。习惯上常量名使用全大写。</p><p>如果希望在某一个类中的常量可以在类中多个方法中使用，通常称这些常量为<strong>类常量</strong>，使用关键字<strong>static final</strong>设置。</p><div class="language-Java ext-Java line-numbers-mode"><pre class="language-Java"><code>public class Constants2{\n    public static final double CM_PER_INCH = 2.54;\n    public static void main(Stringn args){\n        double paperWidth = 8.5;\n        double paperHeight = 11;\n         System.out.println(&quot;Paper size in centimeters: &quot;\n              + paperWidth * CMJERJNCH +\n              &quot; by &quot; + paperHeight * CM_PER_INCH) ;\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_3-5-运算符" tabindex="-1"><a class="header-anchor" href="#_3-5-运算符" aria-hidden="true">#</a> 3.5 运算符</h3><p>Java 中使用算术运算符+、—、*、/。</p><p>参与/运算的两个数都是整数除法，否则，表示浮点除法。</p><h4 id="_3-5-1-数学函数与常量" tabindex="-1"><a class="header-anchor" href="#_3-5-1-数学函数与常量" aria-hidden="true">#</a> 3.5.1 数学函数与常量</h4><p>计算一个数的平方根：</p><div class="language-Java ext-Java line-numbers-mode"><pre class="language-Java"><code>Math.sqrt(16);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>幂运算：</p><div class="language-Java ext-Java line-numbers-mode"><pre class="language-Java"><code>Math.pow(x,y);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>相当于 x^y^</p><p><code>floorMod</code>方法</p><p>floorMod 方法的目的是解决一个长期存在的有关整数余数的问题。 考虑表达式 n % 2。所有人都知道， 如果 n 是偶数， 这个表达式为 0 ; 如果 n 是奇数， 表达式则为 1。 当然， 除非 n 是负数。</p><p>如果 n 为负，这个表达式则为-1。为什么呢？ 设计最早的计算机时，必须有人制定规则， 明确整数除法和求余对负数操作数该如何处理。数学家们几百年来都知道这样一个最优（或“ 欧几里德”）规则：余数总是要&gt;=0。不过， 最早制定规则的人并没有翻开数学书好好研究，而是提出了一些看似合理但实际上很不方便的规则。</p><p>下面考虑这样一个问题： 计算一个时钟时针的位置。这里要做一个时间调整， 而且要归一化为一个 0 ~ 11 之间的数。 这很简单：（position + adjustment) % 12。不过， 如果这个调整为负会怎么样呢？ 你可能会得到一个负数。所以要引入一个分支， 或者使用（(position +adjustment) % 12 + 12) % 12。不管怎样， 总之都很麻烦。</p><p>floorMod 方法就让这个问题变得容易了： floorMod(position + adjustment, 12) 总会得到一个 0 ~ 11 之间的数。（遗憾的是，对于负除数，floorMod 会得到负数结果， 不过这种情况在实际中很少出现。）</p><blockquote><p>不必一直添加 Math 前缀，只需要在 java 文件的开头静态导入<code>import static java.lang.Math.*</code></p></blockquote><h4 id="_3-5-2-数值类型之间的转换" tabindex="-1"><a class="header-anchor" href="#_3-5-2-数值类型之间的转换" aria-hidden="true">#</a> 3.5.2 数值类型之间的转换</h4><p><img src="https://secure-static.wolai.com/static/kCgPcuiHWoJ9J9Fz8mJnaH/image.png" alt=""></p><p>实心箭头表示无信息丢失的转换，虚线箭头表示有信息丢失的转换。</p><p>123456789 是一个大整数，它所包含的位数比 float 类型所能表达的位数多。当将这个整型数值转换为 float 时，将会得到同样大小的结果，但却失去了一定的精度。</p><div class="language-Java ext-Java line-numbers-mode"><pre class="language-Java"><code>int n = 123456789;\nfloat a = n;// f == 1.234567892E8\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>当使用上面两个不同类型的数值进行计算时，需要将他们转换为同一种类型，再进行计算。</p><div class="language-Java ext-Java line-numbers-mode"><pre class="language-Java"><code>if 两个操作数中有一个是double类型，另一个操作数就转换为double类型\nelse 其中有一个是float类型，另一个转换为float类型\nelse 其中有一个是long类型，另一个就转换为long类型\nelse 两个都转换为int类型\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_3-5-3-强制类型转换" tabindex="-1"><a class="header-anchor" href="#_3-5-3-强制类型转换" aria-hidden="true">#</a> 3.5.3 强制类型转换</h4><div class="language-Java ext-Java line-numbers-mode"><pre class="language-Java"><code>double x = 9.997;\nint nx = (int)x;\n// nx = 9\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>浮点数转换为整型时会截断小数部分</p><p>如果想要得到舍入的最接近整数，就使用 Math.round 方法：</p><div class="language-Java ext-Java line-numbers-mode"><pre class="language-Java"><code>double x = 9.997;\nint nx = (int)Math.round(x);// nx = 10\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>为什么仍然需要进行强制类型转换？</p><p>round 方法返回的结果为 long 类型</p><h4 id="_3-5-4-结合赋值和运算符" tabindex="-1"><a class="header-anchor" href="#_3-5-4-结合赋值和运算符" aria-hidden="true">#</a> 3.5.4 结合赋值和运算符</h4><p><code>x += 4</code></p><p>如果运算符得到了一个值，其类型与左侧的变量类型不同，那么就会默认进行强制类型转换。例如：x 是一个 int 类型，x += 3.5 是合法的，相当于(int)(x+3.5)</p><h4 id="_3-5-5-自增和自减运算符" tabindex="-1"><a class="header-anchor" href="#_3-5-5-自增和自减运算符" aria-hidden="true">#</a> 3.5.5 自增和自减运算符</h4><p>i++ ++i</p><p>作为单独的语句使用时两者没有区别。作为表达式运算时，前缀：先自增再使用变量；后缀：先使用变量再自增</p><h4 id="_3-5-6-关系和-boolean-运算符" tabindex="-1"><a class="header-anchor" href="#_3-5-6-关系和-boolean-运算符" aria-hidden="true">#</a> 3.5.6 关系和 boolean 运算符</h4><p>如果第一个操作数已经能确定表达式的值，那么后面的计算就不需要再进行。</p><p>expression~1~ &amp;&amp; expression~2~ 而且已经计算得到第一个表达式的真值为 false, 那么结果就不可能为 true。</p><p>进行应用：<code>x!=0 &amp;&amp; 1/x&gt;2</code>如果 x==0，那么就可以避免进行后面的错误运算</p><h4 id="_3-5-7-位运算符" tabindex="-1"><a class="header-anchor" href="#_3-5-7-位运算符" aria-hidden="true">#</a> 3.5.7 位运算符</h4><h4 id="_3-5-8-括号与运算符级别" tabindex="-1"><a class="header-anchor" href="#_3-5-8-括号与运算符级别" aria-hidden="true">#</a> 3.5.8 括号与运算符级别</h4><h4 id="_3-5-9-枚举类型" tabindex="-1"><a class="header-anchor" href="#_3-5-9-枚举类型" aria-hidden="true">#</a> 3.5.9 枚举类型</h4><p>有时，变量的取值只限于几个值之间。例如：s,m,l,xl... 如果使用平常的方式定义值，有可能会出现限定值之外的情况。那么，我们就需要一个枚举类型。枚举类型包括有限个命名的值。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">enum</span> SIZE <span class="token punctuation">{</span> SMALL<span class="token punctuation">,</span> MEDIUM<span class="token punctuation">,</span> LARGE <span class="token punctuation">}</span>\n<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SIZE<span class="token punctuation">.</span>SMALL<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// output: SMALL</span>\n\n<span class="token class-name">SIZE</span> s <span class="token operator">=</span> SIZE<span class="token punctuation">.</span>LARGE<span class="token punctuation">;</span>\n<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// output: LARGE</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>SIZE 类型的变量只能赋值为有限的值（即类型声明中的值）或 null</p><h3 id="_3-6-字符串" tabindex="-1"><a class="header-anchor" href="#_3-6-字符串" aria-hidden="true">#</a> 3.6 字符串</h3><p>待写</p><h3 id="_3-7-输入输出" tabindex="-1"><a class="header-anchor" href="#_3-7-输入输出" aria-hidden="true">#</a> 3.7 输入输出</h3><p>待写</p><h3 id="_3-8-控制流程" tabindex="-1"><a class="header-anchor" href="#_3-8-控制流程" aria-hidden="true">#</a> 3.8 控制流程</h3><p>待写</p><h3 id="_3-9-大数值" tabindex="-1"><a class="header-anchor" href="#_3-9-大数值" aria-hidden="true">#</a> 3.9 大数值</h3><p>待写</p><h3 id="_3-10-数组" tabindex="-1"><a class="header-anchor" href="#_3-10-数组" aria-hidden="true">#</a> 3.10 数组</h3><p>待写</p><h2 id="第-4-章-对象与类" tabindex="-1"><a class="header-anchor" href="#第-4-章-对象与类" aria-hidden="true">#</a> 第 4 章 对象与类</h2><h3 id="_4-6-对象构造" tabindex="-1"><a class="header-anchor" href="#_4-6-对象构造" aria-hidden="true">#</a> 4.6 对象构造</h3><h4 id="_4-6-1-重载" tabindex="-1"><a class="header-anchor" href="#_4-6-1-重载" aria-hidden="true">#</a> 4.6.1 重载</h4><p>有些类有多个构造器。例如，StringBuilder 有多个构造方法</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// or</span>\n<span class="token class-name">StringBuilder</span> sb2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这种特征叫做重载（overloading）。如果多个方法有相同的名字，不同的参数，便会产生重载。编译器会对相匹配的方法进行<strong>挑选</strong>。</p><details class="custom-container details"><summary>挑选</summary><p>挑选： 现在我们已经知道（如上 StringBuilder 的例子），两个相同名字的构造方法，它们有不同的参数。当我们在使用方法时，无论使用了无参方法还是有参方法，编译器会对相对应的方法进行匹配，即当我们使用无参构造方法，编译器自动寻找相应的无参构造方法。</p></details><p>如果编译器挑选不出，就会产生编译时错误。 这个过程称为重载解析（overloading resolution）。</p><p><strong>关于重载还有其它的知识点，后期再说</strong></p><h4 id="_4-6-2-默认域初始化" tabindex="-1"><a class="header-anchor" href="#_4-6-2-默认域初始化" aria-hidden="true">#</a> 4.6.2 默认域初始化</h4><p>如果创造变量的时候没有给变量赋值，那么 java 会默认给变量赋予一个值。</p><table><thead><tr><th style="text-align:center;">类型</th><th style="text-align:center;">值</th></tr></thead><tbody><tr><td style="text-align:center;">int</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">long</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">boolean</td><td style="text-align:center;">false</td></tr><tr><td style="text-align:center;">float</td><td style="text-align:center;">0.0</td></tr><tr><td style="text-align:center;">double</td><td style="text-align:center;">0.0</td></tr><tr><td style="text-align:center;">char</td><td style="text-align:center;">/u0000(NULL)</td></tr><tr><td style="text-align:center;">string</td><td style="text-align:center;">NULL</td></tr><tr><td style="text-align:center;">Object</td><td style="text-align:center;">NULL</td></tr><tr><td style="text-align:center;">[]</td><td style="text-align:center;">NULL</td></tr><tr><td style="text-align:center;">[int,float...]</td><td style="text-align:center;">[0,0.0,...]</td></tr></tbody></table><h4 id="_4-6-3-无参数的构造器" tabindex="-1"><a class="header-anchor" href="#_4-6-3-无参数的构造器" aria-hidden="true">#</a> 4.6.3 无参数的构造器</h4><p>很多类会包含一个无参数的构造函数，对象由无参构造函数创建时，里面的成员变量会被设置为一个默认值（如果没有被特殊赋值的话）。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Other</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> a<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token class-name">Other</span> other <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Other</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\noutput<span class="token operator">:</span> <span class="token number">0</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>如果在编写类时没有提供无参的构造器，那么系统会默认提供一个无参数构造器。构造器会将所有的成员变量设置为相应的默认值。数值型设置为 0，布尔型设置为 false，其它类型设置为 null。</p></div><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>如果在编写类时已经提供有参构造器，此时再使用无参构造器创建实例，会产生错误。</p></div><h4 id="_4-6-4-显示域初始化" tabindex="-1"><a class="header-anchor" href="#_4-6-4-显示域初始化" aria-hidden="true">#</a> 4.6.4 显示域初始化</h4><p>使用有参构造函数，或者在声明成员变量时初始化变量。</p><h4 id="_4-6-5-参数名" tabindex="-1"><a class="header-anchor" href="#_4-6-5-参数名" aria-hidden="true">#</a> 4.6.5 参数名</h4><p>请采用易懂的参数名，不要嫌长</p><h4 id="_4-6-6-调用另一个构造器" tabindex="-1"><a class="header-anchor" href="#_4-6-6-调用另一个构造器" aria-hidden="true">#</a> 4.6.6 调用另一个构造器</h4><p>如果构造器中使用<code>this(args[])</code>这样的形式，即可引用类中其它的构造函数</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>这样的引用必须是方法中的第一条语句 否则会有错误：Call to &#39;this()&#39; must be first statement in constructor body</p></div><h4 id="_4-6-7-初始化块" tabindex="-1"><a class="header-anchor" href="#_4-6-7-初始化块" aria-hidden="true">#</a> 4.6.7 初始化块</h4><p>前面有两种初始化数据域的方法</p><ul><li>在构造器中设置值</li><li>在声明中赋值 现在来介绍第三种机制，称为<strong>初始化块</strong>(initialization block)。在类的声明中，可以包含多个代码块，只要类的对象被构造，这些块就会执行。</li></ul><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> nextId<span class="token punctuation">;</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">double</span> salary<span class="token punctuation">;</span>\n\n    <span class="token comment">// initialization block</span>\n    <span class="token punctuation">{</span>\n        id <span class="token operator">=</span> nextId<span class="token punctuation">;</span>\n        nextId<span class="token operator">++</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> n<span class="token punctuation">,</span> <span class="token keyword">double</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> n<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> s<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>一般来说，初始化块放在需要初始化的变量之后。但是即使是在块后面定义的变量，也可以在块中初始化，但是<strong>不建议这样做</strong>，有可能会产生循环定义的问题。</p></div><p><strong>调用构造器的具体处理步骤</strong></p><ol><li>所有数据域被初始化为默认值（即使在后面的构造器中没有提及此变量）</li><li>按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块</li><li>如果构造器调用了第二个构造器，则先执行第二个构造器</li><li>继续执行构造器</li></ol><details class="custom-container details"><summary>实例代码</summary><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Other</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">String</span> s<span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token class-name">Other</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">public</span> <span class="token class-name">Other</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>s <span class="token operator">=</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> a<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>这段代码的执行过程为</strong></p><ol><li>初始化 a=0，s=null</li><li>执行<code>Other()</code>，调用<code>Other(String s)</code>给 s 赋值为&quot;1&quot;</li><li>返回<code>Other()</code>方法，执行完毕</li></ol></details><p><strong>静态域</strong></p><p>可以在声明静态域时提供初始化值，或者在静态初始化块中进行初始化。 如果代码比较简单：<code>private static int nextId = 0</code>，可以直接进行初始化 如果初始化的代码比较复杂，建议放在静态初始化块中</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Random</span> generator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    nextId <span class="token operator">=</span> generator<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在类第一次加载的时候，将会进行静态域的初始化。与实例域一样，除非显式地设置值，否则采用默认值。所有的静态初始化语句和静态初始化块都按照类定义的顺序执行。</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>在 JDK6 之前，即使没有 main 方法也能编写 java 程序</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>\n    <span class="token keyword">static</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>当使用<code>java Main</code>调用此类时，会先执行静态代码块，打印语句，然后显示消息，指出 main 方法未定义。在 java7 之后，java 程序会优先判断是否有 main 方法</p></div><h4 id="_4-6-8-对象析构与-finalize-方法" tabindex="-1"><a class="header-anchor" href="#_4-6-8-对象析构与-finalize-方法" aria-hidden="true">#</a> 4.6.8 对象析构与 finalize 方法</h4><p>有些语言，如 c++，会有显式的析构器，其中会有当对象不再使用时进行清理的代码。在析构器中，最常见的操作是回收分配给对象的存储空间。Java 有自动的垃圾回收器，所以没有析构器。 可以为任何一个类添加 finalize 方法。此方法在垃圾回收器清除对象之前调用，在实际应用中，不要依赖于此方法，因为不知道方法什么时候调用。 资源使用完毕后，可以手动关闭，即 close 方法。</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>有个名为 System.mnFinalizersOnExit(true) 的方法能够确保 finalizer 方法在 Java 关闭前被调用。 不过， 这个方法并不安全，也不鼓励大家使用。有一种代替的方法是使用方法 Runtime.addShutdownHook 添加“关闭钩” （shutdown hook), 详细内容请参看 API 文档。</p></div><h3 id="_4-7-包" tabindex="-1"><a class="header-anchor" href="#_4-7-包" aria-hidden="true">#</a> 4.7 包</h3><p>Java 使用包将类组织起来。所有标准的 Java 包都处于 java 和 javax 包中。</p><p>如果两个人同时创建了相同名字的类，那么不同的包名，就保证他们的类不会冲突。</p><h4 id="_4-7-1-类的导入" tabindex="-1"><a class="header-anchor" href="#_4-7-1-类的导入" aria-hidden="true">#</a> 4.7.1 类的导入</h4><h4 id="_4-7-2-静态导入" tabindex="-1"><a class="header-anchor" href="#_4-7-2-静态导入" aria-hidden="true">#</a> 4.7.2 静态导入</h4><p>形如<code>import static java.lang.System.*</code>这样的导入形式即为静态导入。 如此之后，就可使用 System 类中的静态方法和域。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>另外，还可以导入特定的方法和域。 <code>import static java.lang.System.out</code></p><h4 id="_4-7-3-将类放入包中" tabindex="-1"><a class="header-anchor" href="#_4-7-3-将类放入包中" aria-hidden="true">#</a> 4.7.3 将类放入包中</h4><h4 id="_4-7-4-包作用域" tabindex="-1"><a class="header-anchor" href="#_4-7-4-包作用域" aria-hidden="true">#</a> 4.7.4 包作用域</h4><p>详细地写一下 private、protect、缺省、public 的作用域</p><h3 id="_4-8-类路径-classpath" tabindex="-1"><a class="header-anchor" href="#_4-8-类路径-classpath" aria-hidden="true">#</a> 4.8 类路径（ClassPath）</h3>',126),p=(0,e.Uk)("此节见"),l={href:"https://www.liaoxuefeng.com/wiki/1252599548343744/1260466914339296",target:"_blank",rel:"noopener noreferrer"},c=(0,e.Uk)("廖雪峰的官方网站"),o=(0,e.uE)('<p><strong>classpath</strong>是什么？</p><p>可以从字面意义上看，<strong>class</strong>即 java 编译后的字节码文件，<strong>path</strong>即路径，合在一起来说就是字节码文件的路径。</p><p><code>classpath</code>是 JVM 会用到的一个环境变量，用来指示 JVM 如何找到 class 文件。如果 JVM 需要执行 class 文件<code>com.company.Hello.class</code>，所以需要知道相应文件的路径才行。</p><p>在不同的系统上，类路径的写法有所不同，在 windows 系统上，多个路径用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>包裹</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>C:<span class="token punctuation">\\</span>work<span class="token punctuation">\\</span>project1<span class="token punctuation">\\</span>bin<span class="token punctuation">;</span>C:<span class="token punctuation">\\</span>shared<span class="token punctuation">;</span><span class="token string">&quot;D:\\My Documents\\project1<span class="token entity" title="\\b">\\b</span>in&quot;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>在 linux 系统，用<code>:</code>来分割路径</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>假设现在的 classpath 是<code>.;C:\\work\\project1\\bin;C:\\shared</code>，JVM 在加载<code>ab.xy.Hello</code>这个类时，依次查找的路径为</p><ul><li>当前目录\\ab\\xy\\Hello.class</li><li>C:\\work\\project1\\bin\\ab\\xy\\Hello.class</li><li>C:\\shared\\ab\\xy\\Hello.class</li></ul><p><code>.</code>代表当前目录，JVM 会依次查找各个路径，找到正确的路径后就不再继续查找，如果没有找到路径，就报错。</p><p><code>classpath</code>的设置有两种方式</p><ol><li>在系统环境变量中设置，不推荐</li><li>在 JVM 启动时设置，推荐<div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>java -classpath <span class="token builtin class-name">.</span><span class="token punctuation">;</span>C:<span class="token punctuation">\\</span>work<span class="token punctuation">\\</span>project1<span class="token punctuation">\\</span>bin<span class="token punctuation">;</span>C:<span class="token punctuation">\\</span>shared abc.xyz.Hello\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div>启动时设置<code>-classpath</code>参数，或<code>-cp</code> 如果没有设置此参数，默认为<code>.</code></li></ol><p>在 IDE 中运行程序，会自动设置项目的 bin 目录和 jar 包为<code>classpath</code></p><p>有时候，我们会引入 java 自带的核心库的代码，这些 java 文件也需要加入 classpath 中吗？</p><div class="custom-container danger"><p class="custom-container-title">不需要！！！</p><p>不要把任何 Java 核心库添加到 classpath 中！JVM 根本不依赖 classpath 加载核心库！</p></div><p>一般来说不需要设置<code>classpath</code>，使用默认的<code>.</code>即可</p><p><strong>jar 包</strong></p><p>如果有很多的<code>class</code>文件放置在不同的目录中，使用起来肯定不方便，如果把他们放在同一个地方就好了！</p><p>jar包把<code>package</code>组织的目录层级，以及目录下的所有文件（包括<code>.class</code>文件和其他文件）都打包好。</p><p>jar包实际上时zip格式的压缩文件，jar包相当于目录</p>',20),i={render:function(a,n){const s=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.j4)(e.HY,null,[t,(0,e.Wm)("p",null,[p,(0,e.Wm)("a",l,[c,(0,e.Wm)(s)])]),o],64)}}}}]);